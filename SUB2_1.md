# 2과목 - 운영체제

<br>

1. 운영체제 시스템 중에서 아래 설명에 해당하는 것은 무엇인가? (나)

   한 컴퓨터를 여러 명의 사용자가 동시에 사용하는 경우 사용자들이 CPU 시간 자원을 나누어 쓰는 방식으로 대부분 다중-사용자, 다중-태스킹 환경을 지원하므로 CRT 터미널을 사용하고 있는 모든 사용자들을 관리해야 하고, 각 사용자들이 컴퓨터 시스템을 사용할 권한이 있는지를 검사해야 하며, 사용자들이 다른 사용자들의 영역을 침범하지 못하도록 보호할 수 있어야 한다. 또한 프로세서를 각 사용자들이 공평하게 배분하여 사용할 수 있어야 한다.

   가. 일괄처리 시스템

   나. 시분할 시스템

   다. 분산 시스템

   라. 실시간 시스템

<br>

2. 다음 중 메모리의 접근 속도가 느린 것에서 빠른 것의 순서로 되어 있는 것은 무엇인가? (다)

   가. 보조기억장치 → 캐시메모리 → 주기억장치

   나. 캐시메모리 → 주기억장치 → 보조기억장치

   다. 보조기억장치 → 주기억장치 → 캐시메모리

   라. 주기억장치 → 보조기억장치 → 캐시메모리

<br>

3. 일반적으로 디스크에 접근하는데 요구되는 시간의 요소들에 대한 설명으로 잘못된 것은 무엇인가? (라)

   가. 탐구시간(seek time) : 기계적인 동작에 의해 읽기/쓰기 헤드를 원하는 트랙에 위치시켜야 하는데 걸리는 시간

   나. 회전지연시간(rotational latency time) : 요구된 자료가 읽기/쓰기 헤드 밑에 이를 때까지 디스크나 드럼을 회전하는데 걸리는 시간

   다. 전송시간(transfer time) : 자료가 보조기억장치에서 주기억장치로 이동되는데 걸리는 시간

   라. 정보저장시간(data store time) : 디스크 내 정보를 읽어 이를 파일로 저장하는데 걸리는 시간

   <br>

   ⇒ 디스크 액세스 시간(disk access time)

   - 탐구시간 + 회전지연시간 + 전송시간

<br>

4. 운영체제 내에서 구동되는 프로세스(Process)에 대한 설명으로 옳지 않은 것은 무엇인가? (라)

   가. PCB(Process Control Block)를 포함하고 있는 프로그램

   나. 운영체제가 관리하는 실행 단위

   다. 지정된 경과를 얻기 위한 일련의 계통적 동작

   라. 동기적 행위를 일으키는 객체

   <br>

   ⇒ 프로세스

   	- 비동기적(비연속적) 행위를 일으키는 주체

<br>

5. 인텔 마이크로프로세서에서는 가상 메모리를 실 메모리로 변환하는 시간을 줄이기 위해 일정 개수의 변환된 주소 값을 저장하여 놓는 공간을 가지고 있다. 이를 무엇이라고 하는가? (나)

   가. 커널 스택(Kernel Stack)

   나. TLB(Translation Lookaside Buffer)

   다. 레지스터(Register)

   라. 프로세스 제어 블록(Process Control Block)

   <br>

   ⇒ TLB

   - 가상 메모리 주소를 물리적인 주소로 변환하는 속도를 높이기 위해 사용되는 캐시
   - 최근에 일어난 가상 메모리 주소와 물리 주소의 변환 테이블을 저장하는 일종의 주소 변환 캐시

<br>

6. 스택을 이용하여 파라미터를 전달할 때 스택에 파라미터를 어떠한 순서로 넣을 것이며 또한 전달되어진 파라미터를 어느 곳에서 해제할 것인가에 따라 여러 가지 방식이 있으며, 이를 콜링 컨벤션(Calling Convention)이라 한다. 다음 중 프로시저를 호출한 쪽(Caller)에서 파라미터에 대한 해제까지 책임지는 콜링 컨벤션은? (가)

   가. __cdecl

   나. __stdcall

   다. __fastcall

   라. __pascall

   <br>

   ⇒ 콜링 컨벤션

   - __cdecl 
     - C 또는 C++ 프로그램에서 파라미터 전달시 디폴트 값
     - 파라미터 전달은 오른쪽에서 왼쪽 방향으로 스택에 저장
     - 파라미터 해제는 프로시저를 호출한 것이 책임짐
   - __stdcall
     - Windows API 프로시저에서 사용
     - 파라미터 전달은 오른쪽에서 왼쪽 방향으로 스택에 저장
     - 파라미터 해제는 프로시저 복귀 전에 이루어짐
   - __fastcall
     - 처음 두 개까지의 파라미터는 스택을 사용하지 않고 ECX, EDX 레지스터 사용
     - 그 이상의 파라미터에 대해서만 오른쪽에서 왼쪽으로 스택에 저장
     - 파라미터 해제는 프로시저 복귀 전에 이루어짐
   - __thiscall
     - 주로 C++의 클래스에서 사용
     - 현재 객체의 포인터 ECX에 전달
     - ECX로 전달되는 값이 this 포인터가 됨
     - 파라미터 전달은 오른쪽에서 왼쪽 방향으로 스택에 저장
     - 파라미터 해제는 프로시저 복귀 전에 이루어짐

<br>

7. 인텔 마이크로프로세서에서 선형 주소를 실제 물리적 주소로 바꾸기 위한 첫 번째 작업은 페이지 디렉토리를 찾는 것이며, 이 페이지 디렉토리의 위치 정보는 "\_\_\_\_\_\_" 레지스터를 통해 얻어낼 수 있다. (라)

   가. ESI

   나. EIP

   다. CR2

   라. CR3

   <br>

   ⇒ 레지스터

   - ESI
     - 데이터 복사나 조작 시 Source Data의 주소 저장
   - EIP
     - 다음에 실행해야 할 명령어가 존재하는 메모리 주소 저장
   - CR2
     - 페이지 폴트 발생 시 페이지 폴트가 발생한 선형 주소 저장
   - CR3
     - 페이지 디렉터리의 물리 주소와 페이지 캐시에 관련된 기능 설정

<br>

8. 인텔 마이크로프로세서에서는 가상 메모리로 0에서 4GBytes까지를 지시할 수 있다. 만약 4KBytes 단위의 크기로 페이징 시스템을 구성하고 모든 가상 메모리의 주소가 페이지 디렉토리와 페이지 테이블에 매핑되어 있다면 이 4GBytes의 가상 메모리를 표현하는데 필요한 페이지 디렉토리와 페이지 테이블은 얼마만큼의 용량을 필요로 하는가? (라)

   가. 1MBytes + 8KBytes

   나. 2MBytes + 8KBytes

   다. 3MBytes + 4KBytes

   라. 4MBytes + 4KBytes

   <br>

   ⇒ 메모리의 크기 : 4GBytes

   - 페이지 디렉토리의 엔트리(1024) * 페이지 테이블의 엔트리(1024) * 페이지 프레임의 크기(4KBytes)
   
   ⇒ 페이지 테이블 : 4Bytes * 1024 * 1024 = 4MBytes
   
   - 엔트리 크기 : 4Bytes
   - 엔트리 개수 : 1024 * 1024
   
   ⇒ 페이지 디렉토리 : 4Bytes * 1024 = 4KBytes
   
   - 엔트리 크기 : 4Bytes
   - 엔트리 개수 : 1024

<br>

9. 인텔 80x86 마이크로프로세서는 서로 다른 예외를 20여 개 발생시키는데, 아래 보기 중 예외와 그에 대한 설명으로 옳지 못한 것은? (나)

   | 예외                          | 설명                                                         |
   | ----------------------------- | ------------------------------------------------------------ |
   | 가. 나누리 에러(Devide error) | 프로그램이 0으로 나누려고 할 때 발생                         |
   | 나. 디버그(Debug)             | eflags의 IF 플래그를 설정했을 때, 혹은 명령어 주소나 피연산자가 활성화된 디버그 레지스터의 범위 안에 들어갈 때 발생 |
   | 다. 중지점(Breakpoint)        | int8 명령으로 발생                                           |
   | 라. 잘못된 TSS(Invalid TSS)   | CPU가 잘못된 태스크 상태 세그먼트를 포함한 프로세스로 컨텍스트를 전환하려는 경우 발생 |
   | 마. 페이지 폴트(Page fault)   | 주소로 참고한 페이지가 메모리에 존재하지 않거나 해당 페이지 테이블 엔트리가 비어 있거나 또는 페이징 보호 메커니즘을 위반한 경우 발생 |

   가. 가, 나

   나. 나, 다

   다. 다, 라

   라. 라, 마

   <br>

   ⇒ 디버그

   - 시스템의 논리적인 오류나 비정상적 연산을 찾아내고 그 원인을 밝히고 수정하는 작업 과정

   ⇒ 중지점

   - 디버깅 목적으로 프로그램을 의도적으로 잠시 또는 아예 멈추게 하는 장소

<br>

10. 컴퓨터 시스템에서 입출력 제어, 인터럽트 처리 등과 관련한 민감한 기게어 명령들은 커널 모드에서만 실행될 수 있게 한다. 이러한 기계어 명령들을 무엇이라 하는가? (가)

    가. Privileged Instruction

    나. Kernel Instruction

    다. Trap Instruction

    라. Atomic Instruction

<br>

11. 운영체제의 구성요소들 중 컴퓨터 시스템의 부팅 시 메모리에 로딩되어 메모리에 상주하면서 시스템 관리는 담당하는 부분을 무엇이라 하는가? (다)

    가. 데몬

    나. 시스템 프로그램

    다. 커널

    라. 유틸리티

<br>

12. 다음 중 Linux 운영체제의 CFS(Completely Fair Scheduling) 스케줄링 기법과 가장 거리가 먼 것은? (가)

    가. 스케줄링 time complexity는 O(1)이다.

    나. Red-black tree를 사용한다.

    다. Active array, Expired array 등 ready queue 구조를 사용한다.

    라. Virtual time slice 개념을 사용한다.

    <br>

    ⇒ CFS

    - 초기의 O(1) 스케줄러 대체 → O(log N)

<br>

13. UNIX에서 프로세스 관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등의 기능을 수행하는 것은? (다)

    가. C Shell

    나. Utility Program

    다. Kernel

    라. Korn Shell

<br>

14. 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위를 의미하는 것은? (가)

    가. Thread

    나. Working Set

    다. Semaphore

    라. Monitor

<br>

15. 디스크 스케줄링의 목적과 거리가 먼 것은? (라)

    가. 처리율 극대화

    나. 평균 반응 시간의 단축

    다. 응답시간 편차의 최소화

    라. 디스크 공간 확보

<br>

16. x86과 x64 프로세서 아키텍처는 4개의 권한 수준(Privilege levels)을 정의하고 있으며, 이 중에서 Windows는 2개의 레벨(kernel mode, user mode)만을 사용하고 있다. 그렇다면 user mode는 어떠한 레벨에 해당되는가? (라)

    가. 0 레벨

    나. 1 레벨

    다. 2 레벨

    라. 3 레벨

<br>

17. 운영체제의 입출력 방식 중 운영체제가 입출력 연산의 종료시점을 결정하고 주기억 장치와 장치 제어기 간 데이터 전송을 CPU가 직접 입출력을 수행하는 방법은? (다)

    가. 인터럽트(Interrupt) 방식 입출력

    나. DMA(Direct Memory Access)에 의한 입출력

    다. 폴링(Polling) 방식 입출력

    라. IO Channel의 사용

    <br>

    ⇒ 인터럽트

    - 입출력 장치에서 자신들이 필요할 때마다 CPU에게 인터럽트 신호를 전송해서 사용하는 방식

    ⇒ DMA

    - CPU가 하는 일을 DMA controller가 대신 하는 방식
    - 입출력 장치간 데이터를 주고 받는 과정이 끝났을 때만 인터럽트가 발생

    ⇒ 폴링

    - CPU가 자신과 연결된 입출력 장치에서 무슨 일이 있는지를 주기적으로 확인하는 방식

    ⇒ IO Channel

    - 시스템의 프로세서와는 독립적으로 입출력만을 제어하기 위한 시스템 구성요소

<br>

18. 윈도우 운영체제의 NTFS 파일 시스템에 대한 설명으로 틀린 것은? (라)

    가. 윈도우 7, 8 버전 운영체제에서만 사용 가능하다.

    나. NTFS 파일 시스템으로 포맷하면 자체의 보안 기능을 사용할 수 있다.

    다. NTFS 파일 시스템이 압축 기능을 지원하므로 별도의 압축 프로그램을 사용하지 않아도 된다.

    라. NTFS 파일 시스템이 암호화 기능을 지원하므로 별도의 암호화 프로그램을 사용하지 않아도 된다.

    <br>

    ⇒ EFS(Encrypting File System)

    - 인증 받지 않은 다른 사용자들이나 프로그램으로부터 데이터 보호
    - NTFS의 특성으로 간주하지 않고, Windows의 한 기능으로 제공

<br>

19. 윈도우 운영체제의 레지스트리 키에 대한 설명 중 맞게 설명한 것은? (다)

    <u>가. HKEY\_CLASS\_ROOT: 파일에 대한 확장자에 대한 정보와 프로그램간의 연결 정보</u>

    나. HKEY_CURRENT_USER: 현재 사용자의 하드웨어와 소프트웨어 대한 버전 정보

    다. HKEY_LOCAL_MACHINE: 윈도우가 설치된 컴퓨터 환경 설정에 대한 정보

    라. HKEY_USERS: 사용자 컴퓨터 환경설정에 대한 정보

    <br>

    ⇒ Windows 레지스트리 메인 키

    - HKEY_CLASS_ROOT
      - 파일 확장자에 따른 연결 프로그램들의 정보, OLE 데이터 등
    - HKEY_CURRENT_USER
      - 현재 로그인해서 시스템을 사용중인 사용자의 배경화면, 디스플레이 설정, 단축아이콘, 응용프로그램 설정 등의 정보
    - HKEY_LOCAL_MACHINE
      - 현재 설치된 하드웨어와 소프트뒈어 설정 및 다양한 환경 정보
    - HKEY_USERS
      - 시스템의 모든 사용자와 그룹에 관한 프로파일 정보
    - HKEY_CURRENT_CONFIG
      - 시스템이 시작할 때 사용되는 하드웨어 프로파일 정보

<br>

20. 하드디스크 구조 중 섹터(Sector)에 대한 내용으로 틀린 것은? (다)

    가. 데이터 기록의 가장 기본 단위이다.

    <u>나. 섹터에 대한 정보(69byte)와 실데이터의 내용이 있는 부분(512byte)로 나눈다.</u>

    다. 공간의 효율성은 향상된다.

    라. 모든 파일은 최소 한 개의 섹터를 사용한다.

    <br>

    ⇒ 섹터

    - 59byte : 각 섹터에서 고유번호 등을 저장하는 용도
    - 512 byte : 사용자들의 데이터 저장에 사용되는 영역

<br>

21. 메모리 분석에 대한 중요성으로 틀린 것은? (라)

    가. 대표적인 휘발성 자료이다.

    나. 사용자의 프라이버시를 보호할 수 있다.

    다. 메모리에 바로 로드되는 악성코드를 확인 가능하다.

    라. 안티 포렌식 기술과 관련 없다.

    <br>

    ⇒ 메모리 분석

    - 메모리에 직접 올라가는 악성 프로그램 등 분석 가능
    - 프라이버시를 위하여 보호된 사용자 데이터들이 메모리에 올라갔을때는 암호화 해제

<br>

22. 소프트웨어를 이용한 메모리 덤프는 DD(Data Dumper)가 있는데 그 종류 중 관련 없는 것은? (라)

    가. FAU DD

    나. DCFLDD

    다. MDD

    라. WDD

    <br>

    ⇒ DD

    - FAU DD
    - DCFLDD
    - KntDD
    - MDD
    - WIN32(64)DD

<br>

23. 가상 메모리에 대한 내용 중 맞는 것은? (가)

    가. RAM + pagefile.sys

    나. ROM + pagefile.sys

    다. RAM + ROM + pagefile.sys

    라. pagefile.sys

    <br>

    ⇒ 가상 메모리(pagefile.sys)

    - 프로그램의 사용 상황에 맞춰 실제 메모리(RAM)와 가상 메모리(pagefile.sys) 사이에서 데이터를 교환하는 방식
      - 실제 메모리 공간이 가득차면 당장 사용되지 않는 내용들을 미리 준비된 하드 디스크의 페이징 파일로 옮겨 실제 메모리에 여유 공간 확보
      - 페이징 파일에 옮겨둔 내용이 필요하면 다시 실제 메모리로 옮겨서 사용

<br>

24. 디스크 스케쥴링 기법의 종류 중 잘못된 것은? (가)

    가. FFCS

    나. SSTF

    다. SCAN

    라. C-SCAN